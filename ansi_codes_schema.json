package sgr

import (
	"encoding/json"
	"fmt"
	"strings"
)

// Registry represents the complete ANSI codes registry
type Registry struct {
	Version    string          `json:"version"`
	Generated  string          `json:"generated"`
	CodeTypes  map[string]int  `json:"code_types"`
	ParamTypes map[string]int  `json:"param_types"`
	Codes      map[string]Code `json:"codes"`
}

// Code represents a single ANSI code definition
type Code struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Abbr        string    `json:"abbr,omitempty"`
	Code        string    `json:"code"`
	Type        string    `json:"type"`
	ParamType   string    `json:"param_type"`
	Symbol      string    `json:"symbol,omitempty"`
	Obsolete    bool      `json:"obsolete,omitempty"`
	Description string    `json:"description,omitempty"`
	Examples    []Example `json:"examples,omitempty"`
}

// Example represents a usage example for a code
type Example struct {
	Description string        `json:"description"`
	Parameters  []interface{} `json:"parameters,omitempty"`
	Output      string        `json:"output"`
}

// AnsiCode represents an ANSI SGR code and its name.
type AnsiCode struct {
	Code   string
	Name   string
	Abbr   string
	Symbol rune // Optional: leave empty if not set
}

func (a AnsiCode) Apply() string {
	return CSI(a.Code)
}

func (a AnsiCode) Render() string {
	return fmt.Sprintf(a.Code + CSI(a.Code) + a.Abbr + string(a.Symbol) + a.Name + Reset.Apply())
}

// Global registry instance
var registry *Registry

// Initialize the registry from JSON data
func InitFromJSON(jsonData []byte) error {
	registry = &Registry{}
	return json.Unmarshal(jsonData, registry)
}

// Get code by ID from registry
func GetCode(id string) (*Code, bool) {
	if registry == nil {
		return nil, false
	}
	code, exists := registry.Codes[id]
	return &code, exists
}

// Convert Code to AnsiCode
func (c *Code) ToAnsiCode() AnsiCode {
	symbol := rune(0)
	if c.Symbol != "" {
		symbol = rune(c.Symbol[0])
	}
	return AnsiCode{
		Code:   c.Code,
		Name:   c.Name,
		Abbr:   c.Abbr,
		Symbol: symbol,
	}
}

// Prepends contextual Control Sequence Introducer commands to an AnsiCode
func CSI(s ...string) string {
	switch s[0] {
	case "A", "B", "C", "D", "E", "F", "G":
		// For options of the form `CSI <n> ac`
		return "\x1b\x5b" + s[1] + s[0]

	case "66":
		// Kitty text sizing protocol:`CSI] 66; metadata; text \x07`
		// Note it uses ] (0x5d)  and not [ (0x5b) after CSI
		if s[1] == "off" || s[1] == "false" {
			return "\x07"
		}
		return "\x1b\x5d" + s[0] + ";" + s[1] + ";" + s[2]

	case "38", "48": //Set foreground/background.
		// Options of the form `CSI ac;5;<n>m`
		return "\x1b\x5b" + s[0] + ";5;" + s[1] + "m"

	default:
		return "\x1b\x5b" + strings.Join(s, ";") + "m"
	}
}

// Dynamic code accessors using registry
var (
	// These will be populated from the registry
	Reset AnsiCode
	
	// C0 control codes
	NUL, BEL, BS, HT, LF, VT, FF, CR, ESC AnsiCode
	
	// SGR codes
	Bold, Dim, Italic, Underline AnsiCode
	
	// Colors
	FgBlack, FgRed, FgGreen, FgYellow, FgBlue, FgMagenta, FgCyan, FgWhite AnsiCode
	BgBlack, BgRed, BgGreen, BgYellow, BgBlue, BgMagenta, BgCyan, BgWhite AnsiCode
	FgDefault, BgDefault AnsiCode
	
	// Bright colors
	FgBrightBlack, FgBrightRed, FgBrightGreen, FgBrightYellow AnsiCode
	FgBrightBlue, FgBrightMagenta, FgBrightCyan, FgBrightWhite AnsiCode
	BgBrightBlack, BgBrightRed, BgBrightGreen, BgBrightYellow AnsiCode
	BgBrightBlue, BgBrightMagenta, BgBrightCyan, BgBrightWhite AnsiCode
)

// Initialize all codes from registry
func initCodes() {
	if registry == nil {
		return
	}
	
	// Map registry codes to variables
	codeMap := map[string]*AnsiCode{
		"reset": &Reset,
		"nul": &NUL, "bel": &BEL, "bs": &BS, "ht": &HT, "lf": &LF,
		"vt": &VT, "ff": &FF, "cr": &CR, "esc": &ESC,
		"bold": &Bold, "dim": &Dim, "italic": &Italic, "underline": &Underline,
		"fg_black": &FgBlack, "fg_red": &FgRed, "fg_green": &FgGreen, "fg_yellow": &FgYellow,
		"fg_blue": &FgBlue, "fg_magenta": &FgMagenta, "fg_cyan": &FgCyan, "fg_white": &FgWhite,
		"bg_black": &BgBlack, "bg_red": &BgRed, "bg_green": &BgGreen, "bg_yellow": &BgYellow,
		"bg_blue": &BgBlue, "bg_magenta": &BgMagenta, "bg_cyan": &BgCyan, "bg_white": &BgWhite,
		"fg_default": &FgDefault, "bg_default": &BgDefault,
		"fg_bright_black": &FgBrightBlack, "fg_bright_red": &FgBrightRed,
		"fg_bright_green": &FgBrightGreen, "fg_bright_yellow": &FgBrightYellow,
		"fg_bright_blue": &FgBrightBlue, "fg_bright_magenta": &FgBrightMagenta,
		"fg_bright_cyan": &FgBrightCyan, "fg_bright_white": &FgBrightWhite,
		"bg_bright_black": &BgBrightBlack, "bg_bright_red": &BgBrightRed,
		"bg_bright_green": &BgBrightGreen, "bg_bright_yellow": &BgBrightYellow,
		"bg_bright_blue": &BgBrightBlue, "bg_bright_magenta": &BgBrightMagenta,
		"bg_bright_cyan": &BgBrightCyan, "bg_bright_white": &BgBrightWhite,
	}
	
	// Populate codes from registry
	for id, ansiCode := range codeMap {
		if code, exists := registry.Codes[id]; exists {
			*ansiCode = code.ToAnsiCode()
		}
	}
}

// Structured accessors using registry
type CursorStruct struct {
	Up, Down, Forward, Back, NextLine, PrevLine, Column, Position, Save, Restore, Hide, Show AnsiCode
}

func NewCursor() CursorStruct {
	if registry == nil {
		return CursorStruct{}
	}
	
	c := CursorStruct{}
	
	// Map cursor codes
	if code, exists := registry.Codes["cursor_up"]; exists {
		c.Up = code.ToAnsiCode()
	}
	if code, exists := registry.Codes["cursor_down"]; exists {
		c.Down = code.ToAnsiCode()
	}
	if code, exists := registry.Codes["cursor_forward"]; exists {
		c.Forward = code.ToAnsiCode()
	}
	if code, exists := registry.Codes["cursor_back"]; exists {
		c.Back = code.ToAnsiCode()
	}
	if code, exists := registry.Codes["cursor_next_line"]; exists {
		c.NextLine = code.ToAnsiCode()
	}
	if code, exists := registry.Codes["cursor_prev_line"]; exists {
		c.PrevLine = code.ToAnsiCode()
	}
	if code, exists := registry.Codes["cursor_column"]; exists {
		c.Column = code.ToAnsiCode()
	}
	if code, exists := registry.Codes["cursor_position"]; exists {
		c.Position = code.ToAnsiCode()
	}
	if code, exists := registry.Codes["cursor_save"]; exists {
		c.Save = code.ToAnsiCode()
	}
	if code, exists := registry.Codes["cursor_restore"]; exists {
		c.Restore = code.ToAnsiCode()
	}
	if code, exists := registry.Codes["cursor_hide"]; exists {
		c.Hide = code.ToAnsiCode()
	}
	if code, exists := registry.Codes["cursor_show"]; exists {
		c.Show = code.ToAnsiCode()
	}
	
	return c
}

// Create global Cursor instance
var Cursor = NewCursor()

// Color helpers using registry
var Fg = struct {
	Color func(n int) AnsiCode
	RGB   func(r, g, b int) AnsiCode
}{
	Color: func(n int) AnsiCode {
		if code, exists := registry.Codes["fg_256"]; exists {
			return AnsiCode{
				Code: fmt.Sprintf("%s;%d", code.Code, n),
				Name: fmt.Sprintf("Fg256(%d)", n),
				Abbr: code.Abbr,
			}
		}
		return AnsiCode{fmt.Sprintf("38;5;%d", n), fmt.Sprintf("Fg256(%d)", n), "", 0}
	},
	RGB: func(r, g, b int) AnsiCode {
		if code, exists := registry.Codes["fg_rgb"]; exists {
			return AnsiCode{
				Code: fmt.Sprintf("%s;%d;%d;%d", code.Code, r, g, b),
				Name: fmt.Sprintf("FgRGB(%d,%d,%d)", r, g, b),
				Abbr: code.Abbr,
			}
		}
		return AnsiCode{fmt.Sprintf("38;2;%d;%d;%d", r, g, b), fmt.Sprintf("FgRGB(%d,%d,%d)", r, g, b), "", 0}
	},
}

var Bg = struct {
	Color func(n int) AnsiCode
	RGB   func(r, g, b int) AnsiCode
}{
	Color: func(n int) AnsiCode {
		if code, exists := registry.Codes["bg_256"]; exists {
			return AnsiCode{
				Code: fmt.Sprintf("%s;%d", code.Code, n),
				Name: fmt.Sprintf("Bg256(%d)", n),
				Abbr: code.Abbr,
			}
		}
		return AnsiCode{fmt.Sprintf("48;5;%d", n), fmt.Sprintf("Bg256(%d)", n), "", 0}
	},
	RGB: func(r, g, b int) AnsiCode {
		if code, exists := registry.Codes["bg_rgb"]; exists {
			return AnsiCode{
				Code: fmt.Sprintf("%s;%d;%d;%d", code.Code, r, g, b),
				Name: fmt.Sprintf("BgRGB(%d,%d,%d)", r, g, b),
				Abbr: code.Abbr,
			}
		}
		return AnsiCode{fmt.Sprintf("48;2;%d;%d;%d", r, g, b), fmt.Sprintf("BgRGB(%d,%d,%d)", r, g, b), "", 0}
	},
}

// Helper functions that use registry
func EraseDisplay(n int) AnsiCode {
	if code, exists := registry.Codes["erase_display"]; exists {
		return AnsiCode{
			Code: fmt.Sprintf("%s;%d", code.Code, n),
			Name: code.Name,
			Abbr: code.Abbr,
		}
	}
	return AnsiCode{fmt.Sprintf("\x1b[%dJ", n), "EraseDisplay", "", 0}
}

func EraseLine(n int) AnsiCode {
	if code, exists := registry.Codes["erase_line"]; exists {
		return AnsiCode{
			Code: fmt.Sprintf("%s;%d", code.Code, n),
			Name: code.Name,
			Abbr: code.Abbr,
		}
	}
	return AnsiCode{fmt.Sprintf("\x1b[%dK", n), "EraseLine", "", 0}
}

func ScrollUp(n int) AnsiCode {
	if code, exists := registry.Codes["scroll_up"]; exists {
		return AnsiCode{
			Code: fmt.Sprintf("%s;%d", code.Code, n),
			Name: code.Name,
			Abbr: code.Abbr,
		}
	}
	return AnsiCode{fmt.Sprintf("\x1b[%dS", n), "ScrollUp", "", 0}
}

func ScrollDown(n int) AnsiCode {
	if code, exists := registry.Codes["scroll_down"]; exists {
		return AnsiCode{
			Code: fmt.Sprintf("%s;%d", code.Code, n),
			Name: code.Name,
			Abbr: code.Abbr,
		}
	}
	return AnsiCode{fmt.Sprintf("\x1b[%dT", n), "ScrollDown", "", 0}
}

// Device status functions
func DeviceStatusReport() AnsiCode {
	if code, exists := registry.Codes["device_status"]; exists {
		return code.ToAnsiCode()
	}
	return AnsiCode{"\x1b[5n", "DeviceStatusReport", "", 0}
}

func DeviceStatusReportCPR() AnsiCode {
	if code, exists := registry.Codes["cursor_position_report"]; exists {
		return code.ToAnsiCode()
	}
	return AnsiCode{"\x1b[6n", "DeviceStatusReportCPR", "", 0}
}

func SoftReset() AnsiCode {
	if code, exists := registry.Codes["soft_reset"]; exists {
		return code.ToAnsiCode()
	}
	return AnsiCode{"\x1b[!p", "SoftReset", "", 0}
}

// Initialize codes when registry is loaded
func init() {
	// You can embed the JSON or load it from file here
	// For now, codes will be initialized when InitFromJSON is called
}
